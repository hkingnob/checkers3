
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Checkers — To Sruthi with love from Haven ;)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React 18 UMD -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel for JSX without a build step -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="min-h-screen bg-gradient-to-b from-emerald-50 to-emerald-100">
  <div id="root"></div>

  <script type="text/babel">
    const { useEffect, useMemo, useState, Fragment } = React;

    // ---------- Helpers ----------
    const inBounds = (r,c) => r>=0 && r<8 && c>=0 && c<8;
    const isDark = (r,c) => (r + c) % 2 === 1;
    const isRed = (v) => v === 'r' || v === 'R';
    const isBlack = (v) => v === 'b' || v === 'B';
    const isKing = (v) => v === 'R' || v === 'B';
    const cloneBoard = (b) => b.map(row => row.slice());

    function initialBoard() {
      const b = Array.from({length:8}, () => Array(8).fill(null));
      for (let r=0;r<3;r++) for (let c=0;c<8;c++) if (isDark(r,c)) b[r][c] = 'b';  // CPU
      for (let r=5;r<8;r++) for (let c=0;c<8;c++) if (isDark(r,c)) b[r][c] = 'r';  // You
      return b;
    }

    function dirsFor(v){
      if (!v) return [];
      if (isKing(v)) return [[-1,-1],[-1,1],[1,-1],[1,1]];
      if (isRed(v))   return [[-1,-1],[-1,1]];  // red moves up
      return [[1,-1],[1,1]];                   // black moves down
    }

    function simpleMovesFrom(board, r, c){
      const v = board[r][c];
      if (!v) return [];
      const out = [];
      for (const [dr,dc] of dirsFor(v)){
        const nr=r+dr, nc=c+dc;
        if (inBounds(nr,nc) && board[nr][nc] === null) out.push({from:{r,c}, to:{r:nr,c:nc}});
      }
      return out;
    }

    function captureStepsFrom(board, r, c){
      const v = board[r][c];
      if (!v) return [];
      const out = [];
      for (const [dr,dc] of dirsFor(v)){
        const mr=r+dr, mc=c+dc;
        const tr=r+2*dr, tc=c+2*dc;
        if (!inBounds(tr,tc)) continue;
        if (board[tr][tc] !== null) continue;
        const mid = board[mr][mc];
        if (!mid) continue;
        if ((isRed(v) && isBlack(mid)) || (isBlack(v) && isRed(mid))){
          out.push({from:{r,c}, to:{r:tr,c:tc}, jumped:{r:mr,c:mc}});
        }
      }
      return out;
    }

    function legalStepsForPiece(board, r, c, player){
      const v = board[r][c];
      if (!v) return [];
      if (player==='r' && !isRed(v)) return [];
      if (player==='b' && !isBlack(v)) return [];
      // Optional-jumps rules: captures allowed but not forced
      return [...captureStepsFrom(board,r,c), ...simpleMovesFrom(board,r,c)];
    }

    function generateAll(board, player){
      const out = [];
      for (let r=0;r<8;r++) for (let c=0;c<8;c++) out.push(...legalStepsForPiece(board,r,c,player));
      return out;
    }

    function applyStep(board, step){
      const b = cloneBoard(board);
      const piece = b[step.from.r][step.from.c];
      b[step.from.r][step.from.c] = null;
      if (step.jumped) b[step.jumped.r][step.jumped.c] = null;
      let np = piece;
      if (piece==='r' && step.to.r===0) np='R';
      if (piece==='b' && step.to.r===7) np='B';
      b[step.to.r][step.to.c] = np;
      return { board: b };
    }

    function counts(board){
      let rMen=0,rKings=0,bMen=0,bKings=0;
      for (let r=0;r<8;r++) for (let c=0;c<8;c++){
        const v=board[r][c];
        if (v==='r') rMen++; else if (v==='R') rKings++;
        else if (v==='b') bMen++; else if (v==='B') bKings++;
      }
      return {rMen,rKings,bMen,bKings};
    }

    function evaluate(board){
      const {rMen,rKings,bMen,bKings} = counts(board);
      const material = (bMen + 2*bKings) - (rMen + 2*rKings);
      const mob = generateAll(board,'b').length - generateAll(board,'r').length;
      return material + 0.05*mob;
    }

    function isTerminal(board){
      const redMoves = generateAll(board,'r').length;
      const blkMoves = generateAll(board,'b').length;
      const {rMen,rKings,bMen,bKings} = counts(board);
      if (rMen + rKings === 0) return {over:true, winner:'b'};
      if (bMen + bKings === 0) return {over:true, winner:'r'};
      if (redMoves===0 && blkMoves===0) return {over:true, winner:'draw'};
      if (redMoves===0) return {over:true, winner:'b'};
      if (blkMoves===0) return {over:true, winner:'r'};
      return {over:false, winner:null};
    }

    function minimax(board, depth, maximizing, alpha, beta){
      const term = isTerminal(board);
      if (term.over || depth===0) return {score: evaluate(board)};

      if (maximizing){ // Black (CPU)
        const moves = generateAll(board,'b');
        if (moves.length===0) return {score: evaluate(board)};
        let bestScore = -Infinity, bestStep;
        for (const mv of moves){
          const {board: after} = applyStep(board, mv);
          const result = minimax(after, depth-1, false, alpha, beta);
          if (result.score > bestScore){ bestScore = result.score; bestStep = mv; }
          alpha = Math.max(alpha, bestScore);
          if (beta <= alpha) break;
        }
        return {score: bestScore, step: bestStep};
      } else { // Red (You)
        const moves = generateAll(board,'r');
        if (moves.length===0) return {score: evaluate(board)};
        let bestScore = Infinity;
        for (const mv of moves){
          const {board: after} = applyStep(board, mv);
          const result = minimax(after, depth-1, true, alpha, beta);
          if (result.score < bestScore){ bestScore = result.score; }
          beta = Math.min(beta, bestScore);
          if (beta <= alpha) break;
        }
        return {score: bestScore};
      }
    }

    // ---------- UI ----------
    function OrcaSVG({ className }) {
      // Simple, bold orca icon (white body, black patches) – looks good small
      return (
        <svg viewBox="0 0 64 40" aria-hidden="true" className={className}>
          <path fill="#ffffff" d="M2 22c4-8 16-14 30-14 10 0 20 3 30 10-6 1-12 4-16 7-9 7-22 9-30 6C8 28 4 25 2 22z"/>
          <ellipse cx="46" cy="16" rx="5" ry="3" fill="#111827"/>
          <circle cx="40" cy="15" r="1.2" fill="#ffffff"/>
          <path d="M14 18c3-5 10-8 18-8" stroke="#111827" strokeWidth="3" fill="none" strokeLinecap="round"/>
          <path d="M10 25c6 5 16 7 26 4" stroke="#111827" strokeWidth="3" fill="none" strokeLinecap="round"/>
          <path d="M6 18c0-3 3-6 6-7" stroke="#111827" strokeWidth="3" fill="none" strokeLinecap="round"/>
          <path d="M52 24c4 1 8 3 10 6" stroke="#111827" strokeWidth="3" fill="none" strokeLinecap="round"/>
          <path d="M28 6c2 2 2 5 1 7" stroke="#111827" strokeWidth="3" fill="none" strokeLinecap="round"/>
        </svg>
      );
    }

    function App(){
      const [board, setBoard] = useState(() => initialBoard());
      const [turn, setTurn] = useState('r');
      const [selected, setSelected] = useState(null);
      const [targets, setTargets] = useState([]);
      const [status, setStatus] = useState('Your turn: Red');
      const [thinking, setThinking] = useState(false);

      const over = useMemo(() => isTerminal(board), [board]);

      useEffect(() => {
        if (over.over){
          setStatus(over.winner==='r' ? 'Game over — You win!' : over.winner==='b' ? 'Game over — CPU wins.' : 'Game over — Draw.');
          return;
        }
        if (turn==='b'){
          setStatus('CPU thinking...');
          setThinking(true);
          setTimeout(() => {
            const { step } = minimax(board, 2, true, -Infinity, Infinity);
            if (!step){
              setThinking(false);
              setStatus('Game over — CPU has no moves. You win!');
              return;
            }
            const { board: after } = applyStep(board, step);
            setBoard(after);
            setThinking(false);
            setTurn('r');
          }, 50);
        } else {
          setStatus('Your turn: Red');
        }
      }, [turn, board]);

      function reset(){
        setBoard(initialBoard());
        setTurn('r');
        setSelected(null);
        setTargets([]);
        setStatus('Your turn: Red');
        setThinking(false);
      }

      function selectSquare(r,c){
        if (over.over || turn!=='r') return;
        const v = board[r][c];
        if (v && isRed(v)){
          const steps = legalStepsForPiece(board, r, c, 'r');
          setSelected({r,c});
          setTargets(steps);
          return;
        }
        if (selected){
          const allowed = targets.find(s => s.to.r===r && s.to.c===c);
          if (allowed){
            const { board: after } = applyStep(board, allowed);
            setBoard(after);
            setSelected(null);
            setTargets([]);
            setTurn('b');
            return;
          }
        }
        setSelected(null);
        setTargets([]);
      }

      function Square({r,c}){
        const piece = board[r][c];
        const isSel = selected && selected.r===r && selected.c===c;
        const legalHere = targets.some(s => s.to.r===r && s.to.c===c);

        const base = isDark(r,c) ? 'bg-emerald-700' : 'bg-emerald-200';
        const highlight = isSel ? 'ring-4 ring-yellow-400' : '';
        const dot = legalHere ? "after:content-[''] after:absolute after:w-3 after:h-3 after:rounded-full after:opacity-90 after:top-1/2 after:left-1/2 after:-translate-x-1/2 after:-translate-y-1/2 after:bg-black/40" : '';

        // Colors for sides (discs behind the orca)
        const discColor =
          piece ? (isRed(piece) ? 'bg-red-500' : 'bg-gray-900') : '';

        return (
          <button
            className={`relative w-12 h-12 sm:w-14 sm:h-14 md:w-16 md:h-16 ${base} ${highlight} flex items-center justify-center`}
            onClick={() => selectSquare(r,c)} disabled={turn!=='r' || thinking}
            aria-label={`square ${r},${c}`}
          >
            <div className={`absolute inset-0 ${dot}`}></div>
            {piece && isDark(r,c) && (
              <div
                className={`w-9 h-9 sm:w-10 sm:h-10 md:w-12 md:h-12 rounded-full shadow-md flex items-center justify-center ${discColor} ${isKing(piece)?'ring-2 ring-white':''}`}
              >
                {/* Orca icon */}
                <OrcaSVG className="w-7 h-7 sm:w-8 sm:h-8 md:w-9 md:h-9" />
                {isKing(piece) && (
                  <span className="absolute -bottom-1 text-[10px] font-bold text-white">K</span>
                )}
              </div>
            )}
          </button>
        );
      }

      return (
        <div className="w-full flex items-center justify-center p-4">
          <div className="w-full max-w-3xl">
            <div className="text-center mb-2">
              <h2 className="text-lg sm:text-xl text-emerald-900">
                To Sruthi with love from Haven ;)
              </h2>
            </div>

            <div className="flex items-center justify-between mb-3">
              <h1 className="text-xl sm:text-2xl font-semibold text-emerald-900">Checkers — Orca Edition</h1>
              <button onClick={reset} className="px-3 py-2 rounded-xl bg-emerald-600 text-white shadow hover:bg-emerald-700 transition">
                New Game
              </button>
            </div>

            <div className="mb-3 text-emerald-900/90 text-sm sm:text-base">{status}</div>

            <div className="aspect-square mx-auto grid grid-cols-8 grid-rows-8 rounded-2xl overflow-hidden shadow-2xl border border-emerald-800/30">
              {Array.from({length:8}).map((_, r) => (
                <Fragment key={r}>
                  {Array.from({length:8}).map((__, c) => <Square key={`${r}-${c}`} r={r} c={c} />)}
                </Fragment>
              ))}
            </div>

            <div className="mt-4 text-xs sm:text-sm text-emerald-900/80 leading-relaxed">
              <p>
                <strong>How to play:</strong> You are
                {' '}<span className="font-semibold text-red-600">Red Orcas</span> and move first.
                Click a piece to see legal targets. Captures are optional in this version.
                Reaching the far row crowns your orca (<span className="font-semibold">K</span>) and allows backward moves.
              </p>
              <p className="mt-1">
                <strong>CPU difficulty:</strong> single level using depth-limited search (alpha–beta).
              </p>
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
